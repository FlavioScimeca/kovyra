---
title: Database Migrations
description: Documentation for TypeORM migrations
---

# Database Migrations

Kovyra uses TypeORM migrations to manage database schema changes in a safe and version-controlled way.

## What Are Migrations?

Migrations are a way to incrementally update the database schema to keep it in sync with the application's data models while preserving existing data. Each migration contains instructions for transforming the database from one version to another.

## Migration Files

Migration files are located in the `server/migrations` directory. Each migration file:

- Is auto-generated by TypeORM
- Contains `up()` and `down()` methods
- Has a timestamp prefix for ordering
- Is written in TypeScript

Example migration file:

```typescript
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddNicknameToUser1745160583857 implements MigrationInterface {
  name = 'AddNicknameToUser1745160583857';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE "users" ADD "nickname" character varying`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE "users" DROP COLUMN "nickname"`);
  }
}
```

## Development vs Production

In development, you have two options:

1. **Auto Synchronize**: Set `synchronize: true` in the database configuration to automatically update the database schema based on entities (not recommended for production).

2. **Use Migrations**: Generate and run migrations to update the schema (recommended for production).

In production, always use migrations with `synchronize: false` to avoid data loss.

## Migration Commands

Kovyra includes the following npm scripts for working with migrations:

| Command                                                       | Description                                      |
| ------------------------------------------------------------- | ------------------------------------------------ |
| `pnpm run migration:generate server/migrations/MigrationName` | Generate a new migration based on entity changes |
| `pnpm run migration:run`                                      | Run all pending migrations                       |
| `pnpm run migration:revert`                                   | Revert the most recent migration                 |

## Migration Workflow

### 1. Modify an Entity

Update an entity file to reflect the desired schema changes. For example:

```typescript
@Entity('users')
export class User {
  // Existing fields...

  @Column({ nullable: true })
  nickname: string; // Add a new column
}
```

### 2. Generate a Migration

```bash
pnpm run migration:generate server/migrations/AddNicknameToUser
```

This command will:

- Compare your entity definitions to the current database schema
- Generate a new migration file with the changes
- Place it in the `server/migrations` directory with a timestamp prefix

### 3. Verify the Migration

Check the generated migration file to ensure it does what you expect:

```typescript
// server/migrations/1745160583857-AddNicknameToUser.ts
public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE "users" ADD "nickname" character varying`);
}

public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE "users" DROP COLUMN "nickname"`);
}
```

### 4. Run the Migration

```bash
pnpm run migration:run
```

This applies all pending migrations in order.

### 5. Verify in the Database

Check that the changes have been applied to the database.

## Reverting Migrations

If you need to undo a migration:

```bash
pnpm run migration:revert
```

This will run the `down()` method of the most recently applied migration.

## Migration Configuration

The migration configuration is defined in `server/config/typeorm.config.ts`:

```typescript
export default new DataSource({
  type: 'postgres',
  host: 'localhost', // Use localhost for CLI migration
  port: parseInt(process.env.DB_PORT || '5432'),
  username: process.env.DB_USERNAME,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_DATABASE,
  entities: [path.join(__dirname, '..', '**', '*.entity.{ts,js}')],
  migrations: [path.join(__dirname, '..', 'migrations', '*.{ts,js}')],
  migrationsTableName: 'migrations',
  synchronize: false, // Important: disabled for migrations
});
```

## Best Practices

1. **Never use `synchronize: true` in production** - it can lead to data loss
2. **Always test migrations** in a development or staging environment
3. **Back up your database** before running migrations in production
4. **Include both `up()` and `down()` methods** to make migrations reversible
5. **Make small, focused migrations** rather than large schema changes
6. **Run migrations during maintenance windows** for production systems
7. **Check migration history** in the `migrations` table in your database

## Troubleshooting

### Migration Not Applying

- Check if the migration has already been applied by looking at the `migrations` table
- Verify that your database connection is correct
- Ensure that the migration file is in the correct directory

### Error During Migration

- Migrations are run inside a transaction, so they should roll back on error
- Check database logs for specific error messages
- Try running the SQL commands manually to debug

### Schema Out of Sync

If your schema gets out of sync:

1. Make a database backup
2. Generate a new migration that brings the schema to the desired state
3. Test thoroughly before applying to production
